\section{Основная часть}
\subsection{Обзор похожих работ}
...

\subsection{Методика тестирования производительности}
Поскольку целью данной работы это оптимизация производительности, то важной задачей становится подбор подходящих метрик для ее измерения. Поскольку FlatArray новая структура данных для Java мира, то готовых бенчмарков не существовало. 
В результате данной работы была создана коллекция тестов, которые измеряют производительность FlatArray по сравнению с обычным Java массивом с учетом различных аспектов.
В частности, тесты измеряют скорость доступа к элементу массиву в зависимости от его длины. Так же учитываются такие факторы, как nullability элемента. Измерение скорости доступа проводится в трех режимах:
\begin{enumerate}
	\item not-existing; структуре данных полностью пуста
	\item fifty-fifty; структура данных на 50\% пуста
	\item only-existing; полная инициализация всех элементов
\end{enumerate}
Помимо сравнения массивов, были созданы тесты, измеряющие производительность HashMap из JDK8 и хеш-таблицы, основанной на FlatArray. Эти бенчмарки позволяют оценить потенциальную применимость данной структуры данных внутри JDK. Они измеряют производительность операции поиска по ключу в трех режимах, описанных в этом разделе.
\par
Ниже в разделах будут описаны конкретные тесты производительности, что они измеряют и зачем. В дальнейшем в работе будут приводится результаты бенчмарков для различных версий FlatArray.
\subsubsection{faMapLoop и mapLoop}
...
\subsubsection{Особенности тестирования производительности в JVM языках}
Как утверждалось ранее, JVM это управляемая среда исполнения с JIT компиляцией и функцией автоматической сборки мусора. Это сильно сказывается на методике измерения, поскольку JVM может выдавать нестабильную производительность. 
В первую очередь это связано с тех, что JVM достигает пиковой производительности далеко не сразу после старта приложения. Среде исполнения необходимо время, чтобы загрузить требуемые классы, создать профиль исполнения приложения, скомпилировать горячие методы и так далее.
Процесс разгона JVM до пиковой производительности называют "warm-up", или "разогревом".
\par
Для тестирования производительности кода, написанного на JVM языках, существуют специализированные инструменты. 
В данной работе применялся Java Microbenchmark Harness\cite{jmh}. Это набор библиотек для измерения производительности небольших кусков кода.
Этот инструмент позволяет разработчику настраивать время warm-up, количество итераций измерений, а так же выбирать формат представления результатов. 
В работе используется throughput, которая выражается в количестве операций в секунду, то есть op/s. 

\subsection{Высокоуровневое представление}

Для Java программиста FlatArray выглядит как обычный Java класс со следующими методами:
\begin{lstlisting}
static <T, S extends FlatArray<T>> S newArray(final Class<S> faClass, final int length)
\end{lstlisting}
Создает новый FA класса S длиной length. Неявно вызывает конструктор c сигнатурой для всех элементов типа T. Проверяет ограничения на S и T перед созданием. Если проверки не были пройдены, кидает соответствующее исключение.
\begin{lstlisting}
T get(final int index)
\end{lstlisting}
Возвращает соответствующий индексу элемент. Бросает ArrayOutOfBoundException, если индекс выходит за границы массива.
\begin{lstlisting}
void set(T object, final int index).
\end{lstlisting}
Копирует поля object в элемент по данному индексу. Если object не null, помечает объект, что то был инициализирован явно. Бросает ArrayOutOfBoundException, если индекс выходит за границы массива.
\begin{lstlisting}
bool sentinel(final int index).
\end{lstlisting}
Проверяет, что элемент по данному индексу явно инициализирован.
\begin{lstlisting}
int length()
\end{lstlisting}
Возвращает длину массива. 
\par
Элемент flattened array реализует интерфейс FAElement, который имеет один метод void set(FAElement object). Он копирует поля object в this. 
Пример использования
\begin{lstlisting}
// Реализация класса элемента
class Point implement FAElement {
	int x, y;
	Point() {
		this.x = 0; 
		this.y = 0; 
	}
	void set(FAElement p) { 
		this.x = ((Point)p).x; 
		this.y = ((Point)p).y; 
	}
}

// FlatArray для данного класса
class PointArray extends FlatArray<Point> {
	private PointArray(final int length) { 
		super(length); 
	}
	public Point get(final int index) { 
		return super.get(index); 
	}
	public void set(Point value, final Point index) { 
		super.set(value, index); 
	}
	public static PointArray newArray(final int length) { 
		return FlatArray.newArray(PointArray.class, length); 
	}
}
\end{lstlisting}

\subsection{Представление внутри виртуальной машины}
Несмотря на то, что идея flattened array достаточно проста, ее реализация потребовала переработки многих компонент виртуальной машины: загрузчика классов, сборщика мусора, внутренний CI (compiler interface), runtime представление классов и Falcon компилятора.
\par 
Стоит отметить, что все Java методы класса FlatArray реализованы внутри виртуальной машины, однако подходы сильно различаются. Так, для режима интерпретации, а так же для исполнения С1 скомпилированных методов, используется native вызов кода внутри виртуальной машины, написанного на С++. Этот подход достаточно прост в исполнении, поскольку не требует глубокой переработки виртуальной машины, однако приводит к дорогостоящему JNI вызову, который потенциально нивелирует все преимущество FA. Более того, при таком подходе невозможны различные оптимизации компилятора, вроде inlinig.
В итоге, это не позволяет использовать все возможные плюсы flattened array. Потому, когда falcon компилирует вызывающий метод, он использует интринсики. Это конструкции, которые выглядят для программиста как обычные функции, но реализуемые компилятором. В нашем случае это подготовленные куски кода на LLVM IR, которые могут быть встроены в вызывающего и оптимизированы под конкретный тип flattened array и его элемента.
В целях отладки была сделана опция виртуальной машины UseFlatArrayIntricics, которая отключает использование интринсиков в falcon скомпилированном коде.   
\par
Одной из самых острых проблем со стороны компилятора, которая привела к изменению в среде исполнения, оказалась свертка размера элемента в константу при выполнении адресной арифметики. Это происходило из-за того, что виртуальная машина не могла связать идентификатор конкретного FlatArray класса (kid - “klass” identifier) с ekid (element “klass” identifier). С помощью kid компилятор может вычислить размер объекта. Кроме того, falcon считал, что вычисленный с помощью адресной арифметики указатель может быть равен null, хотя это не так. 
\par 
Работа с FlatArray начинается с момента инициализации виртуальной машины. Он загружается вместе с другими "well-known" классами и для него создается отдельное внутреннее представление. Когда ...

\subsection{Ограничения}
FlatArray может быть успешно использован далеко не во всех случаях, поскольку имеет ряд ограничений. На данный момент их существует несколько:
\begin{enumerate}
	\item Элемент не должен имеет тип интерфейса, абстрактного класса, массива или flattened array. Другими словами, размер типа элемента массива должен быть вычислим во время компиляции и быть константой.
	\item Класс-элемент реализовывает интерфейс FAElement. Это требование связано с необходимостью распознавать возможные элементы массива во время загрузки класса.
	\item Наследник Flat Array не должен иметь поля. Были проведены измерения, что дополнительные поля внутри FlatArray приводят к ухудшению производительности. Более того, виртуальная машина ожидает конкретную раскладку массива, которая описана в разделе ???.
	\item Нельзя применять Unsafe операции и рефлексию.
	\item Максимальный размер FlatArray равен 16 GB. Это ограничение появилось из-за требований сборщика мусора
	\item Если какой либо объект внутри массива живой с точки зрения сборщика мусора, то весь массив со всеми элементами будут считаться живыми. Большие массивы выделяются аллокатором в отдельном регионе памяти, в котором сборщик мусора \textcolor{red}{ не переносит объекты в другие регионы}. Игнорирование этого ограничения может привести к тому, что в итоге мелкие объекты окажутся в "big space" регионе.
\end{enumerate}

\subsection{Примеры использования}
В этом разделе будет приведено сравнение интерфейсов для работы с Java массивом объектов и FlatArray. Создание объекта выглядит так:
\begin{lstlisting}
// Java objects array
T[] array = new T[length];
// FlatArray
FA array = FlatArray.newArray(FA.class, length);
\end{lstlisting}
Проверка на "null" и доступ к элементу:
\begin{lstlisting}
// Java objects array
if (array[idx] != null) {
	field = array[idx].field;
}
// FlatArray
if (array.sentinel(idx)) {
	field = array.get(idx).field;
}
\end{lstlisting}
Инициализация элемента:
\begin{lstlisting}
// Java objects array
array[idx] = new T(arg1, arg2);
// FlatArray
array.get(idx).arg1 = arg1;
array.get(idx).arg2 = arg2;
array.mark(idx, true);
\end{lstlisting}
\subsection{Потенциальные случаи использования}


\clearpage