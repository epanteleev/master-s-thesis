\section{Основная часть}
\subsection{Обзор похожих работ}
...

\subsection{Методика тестирования производительности}
Поскольку целью данной работы это оптимизация производительности, то важной задачей становится подбор подходящих метрик для ее измерения. FlatArray новая структура данных для Java мира и готовых бенчмарков для ее тестирования не существовало. 
В результате данной работы была создана коллекция тестов, которые измеряют производительность FlatArray по сравнению с обычным Java массивом с учетом различных аспектов.
В частности, тесты измеряют скорость доступа к элементу массиву в зависимости от его длины. Так же учитываются такие факторы, как \textcolor{red}{nullability} элемента. Измерение скорости доступа проводится в трех режимах:
\begin{enumerate}
	\item not-existing; структуре данных полностью пуста
	\item fifty-fifty; структура данных на 50\% пуста
	\item only-existing; полная инициализация всех элементов
\end{enumerate}
Помимо сравнения массивов, были созданы тесты, измеряющие производительность HashMap из JDK8 и хеш-таблицы, основанной на FlatArray. Эти бенчмарки позволяют оценить потенциальную применимость данной структуры данных внутри JDK. Они измеряют производительность операции поиска по ключу в трех режимах, описанных в этом разделе.
Все измерения проводились на компьютере с процессором Intel(R) Xeon(R) E-2134 CPU @ 3.50GHz
с объемом оперативной памяти 64Gb.
\par
Ниже в разделах будут описаны конкретные тесты производительности, что они измеряют и зачем. В дальнейшем в работе будут приводится результаты бенчмарков для различных версий FlatArray.

\subsubsection{flatArrayLoop и basicArrayLoop}
Эти бенчмарки тестируют производительность обхода массива в цикле. Код теста выглядит примерно так:
\begin{lstlisting}
measure() {
	for (int i = 0; i < length; i++) {
		long value = array[indexes[i]].field;
		acc = doSimpleMath(acc, value)
	}
    return acc;
}
\end{lstlisting}
В случае когда 'array' это FlatArray, бенчмарк носит название flatArrayLoop и basicArrayLoop, если в качестве 'array' применяется стандартный Java массив.
Тест обходит 'array' по заранее подготовленным индексам, содержащихся в 'indexes'. 
Из массива извлекается объект, из которого читается поле типа long. В дальнейшем оно используется для вычисления простой арифметики в функции 'doSimpleMath'. 
Массив 'index' предварительно заполняется индексами. При этом существует два режима обхода 'array':
\begin{enumerate}
	\item random; каждый последующий индекс это псевдослучайное число.
	\item forward; индексы идут по возрастающей от 0 до 'length'
\end{enumerate}

\subsubsection{flatArray и basicArray}
Эти тесты используются для измерения скорости одиночного доступа к полю элемента массива. Псевдокод приведен в листинге:
\begin{lstlisting}
measure() {
	long value = array[index].field;
	return value;
}
\end{lstlisting}
В отличие от тестов из прошлого раздела, эти тесты хорошо показывают стоимость адресной арифметики. 
Компилятор способен выносить некоторые вычисления за пределы цикла, что в итоге сказывается на полученных результатах.
В случае FlatArray важно понимать реальные накладные расходы вычисления адреса конкретного поля в зависимости от длины массива.
\subsubsection{flatArraySentinel и basicArraySentinel}
Эти тесты измеряют производительность доступа к элементу с явной проверкой на nullability. Псевдокод показан ниже:
\begin{lstlisting}
measure() { // FlatArray
	if (array.sentinel(index)) {
		acc = array.get(index);
	}
	return acc;
}
measure() { // Java object array.
	Element value = array[index];
	if (value != null) {
		acc = value.field;
	}
	return acc;
}
\end{lstlisting}
\subsubsection{flatArraySentinelLoop и basicArraySentinelLoop}
Этот набор тестов похож на предыдущий, но они работают в цикле. Ниже приведен псевдокод для версии с FlatArray и с обычным Java массивом.
\begin{lstlisting}
measure() {
	for (int i = 0; i < array.length(); i++) {
		if (array.sentinel(indexes[i])) {
			long value = array.get(indexes[i]).field;
			acc = doSimpleMath(acc, value)
		}
	}
	return acc;
}
\end{lstlisting}

\begin{lstlisting}
measure() {
	for (int i = 0; i < array.length(); i++) {
		Element value = array[indexes[i]];
		if (value != null) {
			acc = doSimpleMath(acc, value.field)
		}
	}
	return acc;
}
\end{lstlisting}

\subsubsection{faMapLoop и mapLoop}
Помимо тестов непосредственно на массивы, измерялась производительность двух реализаций java.lang.HashMap. 
Обе базируются на хеш-таблице из JDK8, но одна из них использует FlatArray. 
\par
Эта пара бенчмарков тестирует скорость поиска элемента по ключу в цикле. Их псевдокод приведен ниже.
\begin{lstlisting}
measure() {
	for (int i = 0; i < length; i++) {
		Element value = hashmap.get(keys[i]);
		if (value != null) {
			acc = doSimpleMath(acc, value.field)
		}
	}
	return acc;
}
\end{lstlisting}

\subsubsection{faMap и map}
Помимо тестирования производительности поиска ключей в цикле, полезно измерить скорость одиночного доступа к хеш-таблице.
\begin{lstlisting}
measure() {
	Element value = hashmap.get(key);
	return value.field;
}
\end{lstlisting}
Эти бенчмарки отличаются от faMapLoop и mapLoop. Было замечено, что компилятор по разному оптимизирует эти два типа бенчмарок, а потому результаты для \textcolor{red}{выявления полной картины} необходимы измерения обоих. 
\subsubsection{Особенности тестирования производительности в JVM языках}
Как утверждалось ранее, JVM это управляемая среда исполнения с JIT компиляцией и функцией автоматической сборки мусора. Это сильно сказывается на методике измерения, поскольку JVM может выдавать нестабильную производительность. 
В первую очередь это связано с тех, что JVM достигает пиковой производительности далеко не сразу после старта приложения.
Среде исполнения необходимо время, чтобы загрузить требуемые классы, создать профиль исполнения приложения, скомпилировать горячие методы и так далее.
Процесс разгона JVM до пиковой производительности называют "warm-up", или "разогревом".
\par
Для тестирования производительности кода, написанного на JVM языках, существуют специализированные инструменты. 
В данной работе применялся Java Microbenchmark Harness\cite{jmh}. Это набор библиотек для измерения производительности небольших кусков кода.
Этот инструмент позволяет разработчику настраивать время warm-up, количество итераций измерений, а так же выбирать формат представления результатов. 
В работе используется throughput, которая выражается в количестве операций в секунду, то есть op/s. 

\subsection{Высокоуровневое представление}
Для Java программиста FlatArray выглядит как обычный Java класс со следующими методами:
\begin{lstlisting}
static <T, S extends FlatArray<T>> S newArray(final Class<S> faClass, final int length)
\end{lstlisting}
Создает новый FA класса S длиной length. Неявно вызывает конструктор c сигнатурой для всех элементов типа T. Проверяет ограничения на S и T перед созданием. Если проверки не были пройдены, кидает соответствующее исключение.
\begin{lstlisting}
T get(final int index)
\end{lstlisting}
Возвращает соответствующий индексу элемент. Бросает ArrayOutOfBoundException, если индекс выходит за границы массива.
\begin{lstlisting}
void set(T object, final int index).
\end{lstlisting}
Копирует поля object в элемент по данному индексу. Если object не null, помечает объект, что то был инициализирован явно. Бросает ArrayOutOfBoundException, если индекс выходит за границы массива.
\begin{lstlisting}
bool sentinel(final int index).
\end{lstlisting}
Проверяет, что элемент по данному индексу явно инициализирован.
\begin{lstlisting}
int length()
\end{lstlisting}
Возвращает длину массива. 
\par
Элемент flattened array реализует интерфейс FAElement, который имеет один метод void set(FAElement object). Он копирует поля object в this. 
Пример использования
\begin{lstlisting}
// Реализация класса элемента
class Point implement FAElement {
	int x, y;
	Point() {
		this.x = 0; 
		this.y = 0; 
	}
	void set(FAElement p) { 
		this.x = ((Point)p).x; 
		this.y = ((Point)p).y; 
	}
}

// FlatArray для данного класса
class PointArray extends FlatArray<Point> {
	private PointArray(final int length) { 
		super(length); 
	}
	public Point get(final int index) { 
		return super.get(index); 
	}
	public void set(Point value, final Point index) { 
		super.set(value, index); 
	}
	public static PointArray newArray(final int length) { 
		return FlatArray.newArray(PointArray.class, length); 
	}
}
\end{lstlisting}

\subsection{Представление внутри виртуальной машины}
Несмотря на то, что идея flattened array достаточно проста, ее реализация потребовала переработки многих компонент виртуальной машины: загрузчика классов, сборщика мусора, внутренний CI (compiler interface), runtime представление классов и Falcon компилятора.
\par 
Стоит отметить, что все Java методы класса FlatArray реализованы внутри виртуальной машины, однако подходы сильно различаются. Так, для режима интерпретации, а так же для исполнения С1 скомпилированных методов, используется native вызов кода внутри виртуальной машины, написанного на С++. Этот подход достаточно прост в исполнении, поскольку не требует глубокой переработки виртуальной машины, однако приводит к дорогостоящему runtime вызову, который потенциально нивелирует все преимущество FlatArray. Более того, при таком подходе невозможны различные оптимизации компилятора, вроде открытой подстановки (inlining).
В итоге, это не позволяет использовать все возможные плюсы flattened array. Потому, когда falcon компилирует вызывающий метод, он использует интринсики. Как упоминалось ранее, это конструкции, которые выглядят для программиста как обычные функции, но они реализуются компилятором. В нашем случае это подготовленные куски кода на LLVM IR, которые могут быть встроены в вызывающего и оптимизированы под конкретный тип flattened array и его элемента.
В целях отладки была сделана опция виртуальной машины UseFlatArrayIntricics, которая отключает использование интринсиков в falcon скомпилированном коде.   
\par
Одной из самых острых проблем со стороны компилятора, которая привела к изменению в среде исполнения, оказалась свертка размера элемента в константу при выполнении адресной арифметики. Это происходило из-за того, что виртуальная машина не могла связать идентификатор конкретного FlatArray класса (kid - “klass” identifier) с ekid (element “klass” identifier). С помощью kid компилятор может вычислить размер объекта. Кроме того, falcon считал, что вычисленный с помощью адресной арифметики указатель может быть равен null, хотя это не так. 
В итоге эта проблема была успешно решена
\par 
Работа с FlatArray начинается с момента инициализации виртуальной машины. Он загружается вместе с другими "well-known" классами и для него создается отдельное внутреннее представление. 
Когда JVM начинает загружать наследников класса FlatArray, она так же создает для них отдельное представление.
Это необходимо из-за следующих причин:
\begin{enumerate}
	\item Альтернативный подход к трассировки объекта сборщиком мусора
	\item Необходимость связывать идентификатор класса FlatArray или его наследника с идентификатором элемента массива. В частности, компилятору необходима такая информация для проведения оптимизаций.
\end{enumerate}

\subsection{Ограничения}
FlatArray может быть успешно использован далеко не во всех случаях, поскольку имеет ряд ограничений. На данный момент их существует несколько:
\begin{enumerate}
	\item Элемент не должен имеет тип интерфейса, абстрактного класса, массива или flattened array. Другими словами, размер типа элемента массива должен быть вычислим во время компиляции и быть константой.
	\item Класс-элемент реализовывает интерфейс FAElement. Это требование связано с необходимостью распознавать возможные элементы массива во время загрузки класса.
	\item Наследник Flat Array не должен иметь поля. Были проведены измерения, что дополнительные поля внутри FlatArray приводят к ухудшению производительности. Более того, виртуальная машина ожидает конкретную раскладку массива, которая описана в разделе ???.
	\item Нельзя применять Unsafe операции и рефлексию.
	\item Максимальный размер FlatArray равен 16 GB. Это ограничение появилось из-за требований сборщика мусора
	\item Если какой либо объект внутри массива живой с точки зрения сборщика мусора, то весь массив со всеми элементами будут считаться живыми. Большие массивы выделяются аллокатором в отдельном регионе памяти, в котором сборщик мусора \textcolor{red}{ не переносит объекты в другие регионы}. Игнорирование этого ограничения может привести к тому, что в итоге мелкие объекты окажутся в "big space" регионе.
\end{enumerate}

\subsection{Примеры использования}
В этом разделе будет приведено сравнение интерфейсов для работы с Java массивом объектов и FlatArray. Создание объекта выглядит так:
\begin{lstlisting}
// Java objects array
T[] array = new T[length];
// FlatArray
FA array = FlatArray.newArray(FA.class, length);
\end{lstlisting}
Проверка на "null" и доступ к элементу:
\begin{lstlisting}
// Java objects array
if (array[idx] != null) {
	field = array[idx].field;
}
// FlatArray
if (array.sentinel(idx)) {
	field = array.get(idx).field;
}
\end{lstlisting}
Инициализация элемента:
\begin{lstlisting}
// Java objects array
array[idx] = new T(arg1, arg2);
// FlatArray
array.get(idx).arg1 = arg1;
array.get(idx).arg2 = arg2;
array.mark(idx, true);
\end{lstlisting}

\subsection{Потенциальные случаи использования}

\clearpage