
\section{Обзор предметной области} \label{view}

\subsection{Язык Java} \label{Java}
Язык программирования Java разработан как язык общего назначения. Его синтаксис похож на С++, однако большинство небезопасных операций, вроде адресной арифметики, недопустимы. Вместо этого язык предлагает механизм сборки мусора и синхронизации потоков.
\par
Большим преимуществом Java является мультиплатформенность, а потому она используется в написании программ для различных операционных систем и процессорных архитектур. 
Маленькие встраиваемые системы с ограниченным количеством ресурсов, такие как мобильные телефоны, могут быть запрограммированы с помощью Java Platform Micro Edition. Для рабочих станций существует Java Platform Standard Edition, предоставляющее модули для работы с UI, обработки XML и так далее. Разработка корпоративных приложений может быть упрощена с помощью Java Platform Enterprise Edition.
\par
Поскольку Java работает на большом количестве платформ, то приложения не распространяются как платформо-зависимый машинный код. Вместо этого используется концепция виртуальной машины. Исходный код Java программ компилируется в Java байткод, который вместе с таблицей символов и другой метаинформацией сохраняется в class файл.  Виртуальная машина Java определяется независимо от самого языка спецификацией\cite{java-spec}. Высокая производительность достигается путем just-in-time компиляции. 

\subsection{Profile-guided optimization} \label{pgo}
По сравнению со статически собранными бинарными файлами, исполнение кода с помощью виртуальной машины дает некоторые преимущества, такие как переносимость, безопасность, автоматическое управление памятью, динамическая загрузка кода. Однако это требует применение других алгоритмов оптимизации для получения высокой производительности.
\par
Оптимизация во время исполнения обычно базируется на профиле, собираемого в течение выполнения кода. 
Эта техника позволяет найти наиболее часто исполняемые участки программы, называемыми горячими точками “hot spots”. Горячий код может быть оптимизирован jit компилятором более агрессивно, чем статическим, поскольку виртуальная машина владеет большим контекстом об исполняемой программе. Оптимизации, основанные на сборе профиля, называются profile-guided.

\subsection{JVM}
Java HotSpot Virtual Machine была разработана Sun Microsystems. Виртуальная машина доступна для большого количества платформ и операционных систем. На данный момент поддерживаются архитектуры x64, arm и другие. JVM может работать в операционных системах на базе ядра linux и bsd, а также windows. Виртуальная машина является частью JDK и обычно поставляется вместе с ней. На сегодняшний момент код OpenJDK открыт и доступен для скачивания. Несмотря на это, в момент написания работы существуют коммерческие JDK от других разработчиков.
\par
На сегодняшний момент существует множество компаний, которые предлагают свои реализации JDK, в большей или меньшей степени отличающихся от оригинальной. Сюда относятся Microsoft OpenJDK, Liberica JDK, Amazon Corretto, Azul Platform Prime и другие.
\par
Azul Platform Prime (или, другими словами, Zing) в первую очередь предназначена для использования в больших корпоративных приложениях, такие как высоконагруженные сервера, в которых важны короткие паузы сборки мусора и высокая производительность. 
Более того, в ее состав входит множество специфичных инструментов для анализа работы приложений, которые будут полезны Java разработчику, и виртуальная машина Zing, о которой пойдет речь дальше. В отличии от HotSpot, Zing имеет альтернативу стандартному С2 компилятору под названием Falcon, базирующимся на LLVM. собственный сборщик С4. Это конкурентный, поколенный сборщик мусора\cite{C4-perf}, предназначенный для крупных систем, чувствительным к паузам виртуальной машины.

\subsection{LLVM}
LLVM -- это акроним к "Low Level Virtual Machine". Это набор инструментов и библиотек для 
создания различных компиляторов. С его помощью были разработаны компиляторы для языков С, С++ и многих других. Кроме того, LLVM подходит для написания JIT-компиляторов языков с управляемой средой исполнения, поскольку имеет расширения для поддержки деоптимизаций и сборщика мусора. 
Важнейшим плюсом этой инфраструктуры является хорошо специфицированный промежуточный язык LLVM IR\cite{llvm-ref-man} (Intermediate representation), который фактически представляет собой высокоуровневый ассемблер. 
На основе этого представления работают различные анализаторы кода и оптимизаторы.
LLVM IR базируется на форме единичного статического присваивания (с англ. static single assugment). SSA -- это граф потока управления, в котором каждая переменная имеет только одно присваивание\cite{ssa-book}.
\par
Как упоминалось ранее, компилятор Falcon базируется на инструментарии LLVM. Это позволяет 
виртуальной машине Zing делать более сложный анализ Java кода и производить более сильные оптимизации, чем стандартный C2 компилятор\cite{falcon-gil}.
\par
Важно отметить одну особенность, как C2 и Falcon работают с интринсиками. 
Интринсики -- это специальные функции, реализующиеся самим компилятором. В JVM к их числу относятся широкий перечень математических функции, алгоритмы шифрования, в частности AES, Unsafe операции и так далее.
JVM применяют специально подготовленные разработчиками виртуальной машины функции, называемыми стабами (на англ. StubRoutines). Они обычно пишутся на ассемблере под конкретную
архитектуру и набор инструкций. Другой подход -- это генерация кода интринсика не лету для последующей открытой подстановки в тело вызывающей функции, что используется С2 компилятором для реализации Unsafe функций.
Поскольку Falcon базируется на LLVM, он использует интринсики, написанные LLVM IR. Это дает ряд преимуществ. Во-первых, независимость от архитектуры процессора, во-вторых, упрощает разработку интринсиков.
Важно отметить, что работа с LLVM IR в Zing невозможна без понимания принципов взаимодействия сборщика мусора и компилятора.

\subsubsection{Взаимодействие GC и компилятора}
Для упрощения взаимодействия между сборщиком и скомпилированном кодом, многие GC организованы в терминах 3 абстракций: load и store barrier, safepoint\cite{gc-llvm}:
\begin{itemize}
	\item Load barrier, или барьер чтения – это кусок кода, исполняемый после операции загрузки указателя из памяти, но перед использованием прочитанного значения. Следует отметить, что некоторые сборщики могут не иметь барьера чтения.
	\item Store barrier, или барьер записи  – по аналогии с load barrier это фрагмент кода, который работает перед (или после) выполнением машинной инструкции сохранения указателя, но после получения сохраняемого значения.
	Write барьеры широко применяются для реализации поколенных сборщиков мусора
	\item Safepoint, или безопасная точка – это позиция в коде, где поток исполнения может безопасно остановиться для дальнейшего анализа его контекста. После этой точки видимые компилируемому коду указатели могут быть изменены во время сборки мусора\cite{gc-handbook}. 
	Обычно безопасные точки расставляются в прологах функций и в циклах. Однако бывают случаи, когда поток-мутатор не может достигнуть безопасной точки. Такого рода ошибки называются TTSP (Time To Safepoint issue). 
	Они возникают из-за ошибок внутри виртуальной машины. В этой работе одной из подзадач было устранение TTSP.
\end{itemize}
Сборщик С4 имеет оба вида барьеров. Их наличие приводит к ухудшению общей производительности, поскольку приходится исполнять дополнительный код при чтении или записи указателя. 
Потому разработчики стараются спроектировать как можно более простые барьеры, либо вовсе исключать их. 
Данная работа помогает частично решить проблему удаления load-барьеров.

\subsubsection{Представление Java объекта в памяти}
JVM использует единую модель памяти для все видов объектов, включая массивы и внутренние структуры данных. 
Ссылки на объекты представляют собой прямые указатели. Это обеспечивает быстрый доступ к полям объекта, однако требуется уметь распознавать тип ссылки во время исполнения. 
Каждый объект в Java имеет специальный заголовок, называемый markWord. Он необходим для отображения состояния объекта внутри JVM и имеет сравнительно небольшой размер. 
markWord это внутренняя структура данных, невидимая для Java программиста. Его устройство может быть различным в зависимости от версии JVM и от ее марки. 
В частности, в Zing размер markWord составляет 8 байт, что в 2 раза меньше, чем в Oracle Hotspot. 

\subsection{Система типов Java}
Все типы в языке Java можно разделить на две больших категории: примитивные и ссылочные типы \cite{java-spec}. На сегодняшний момент существует 8 примитивных типов: boolean, int,
long, float, double, byte, char, short. К ссылочным типам относятся объекты классов, интерфейсов, массивов и специальный тип null. Можем выделить некоторые отличия:
\par
Примитивные типы:
\begin{enumerate}
	\item Передача по значению.
	\item Операция "==" сравнивает значения 
\end{enumerate}
Ссылочные типы:
\begin{enumerate}
	\item Передача по ссылке.
	\item Имеют единый родительский класс java.lang.Object
	\item Операция "==" сравнивает указатели на объекты, а не их значения
\end{enumerate}
У ссылочных типов можно выделить подмножество, называемое boxing объекты. Это обертка для примитивных типов, которая позволяет представить их как ссылочные. В необходимо в ряде случаев, например, когда требуется передать примитивный тип в параметр шаблона. В некоторых случаях Java может неявно преобразовывать примитивные типы в ссылочные.
Следует отметить, что, как и Java, JVM оперирует c примитивными и ссылочными типами\cite{jvm-spec}. Более того, для работы с примитивами существуют отдельные инструкции iadd, ladd, fadd, dadd и так далее.
\par
В связи с вышеперечисленным, на данный момент в Java нет возможности создавать собственные типы-значения.

\clearpage
