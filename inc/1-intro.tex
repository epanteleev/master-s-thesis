\section{Введение}
Современные объектно ориентированные языки программирования, такие как Java, предоставляют удобный механизм для написания программ. Обычно приложения представляют собой огромное число классов и модулей. Это очень удобно для программистов этого языка поскольку упрощает написание кода и его читаемость, улучшает его расширяемость.
\par
Однако такая декомпозиция программ может приводить к негативному влиянию на производительность. Огромное число мелких объектов приводит к таким последствиям, как фрагментации памяти, плохой локальности процессорного кеша, а также к увеличению числа чтений указателей из памяти. Эти факторы неизбежно приводят к ухудшению производительности Java приложения.
\par
В этой работе предлагается способ, как можно избежать вышеперечисленные недостатки введением в язык Java новой структуры данных, названной flattened array или FlatArray. Она представляет собой последовательность объектов, как массив структур в С++. Flattened массив имеет ряд преимуществ перед обычным Java массивом объектов:

\begin{enumerate}[align=left]
	\item Позволяет избежать одно разыменование указателя.
	\item Улучшается локальность кеша, поскольку все объекты лежат компактно в одной области памяти, а не разбросаны по всей куче.
	\item Во многих случаях код работы с flattened array автоматически векторизуем компилятором. 
\end{enumerate}

Для Java программиста flattened массив имеет интерфейс обычного Java класса. Данная работа проводилась на базе виртуальной машины Zing. Главными отличиями этой JVM от OpenJDK является замена С2 компилятором Falcon, базирующемся на LLVM, и применением конкурентного сборщика мусора С4\cite{C4collector}.
\par
Flattened array может быть применен для реализации многих других структур данных и алгоритмов, зависящих от скорости доступа к памяти. В частности, в данной работе была реализована альтернативная версия хеш таблицы, которая в некоторых случаях показала лучшую производительность операции поиска.

\subsection{Java} \label{Java}
Язык программирования Java разработан как язык общего назначения. Его синтаксис похож на С++, однако большинство небезопасных операций, вроде адресной арифметики, недопустимы. Вместо этого язык предлагает механизм сборки мусора и синхронизации потоков.
\par
Большим преимуществом Java является мультиплатформенность, а потому она используется в написании программ для различных операционных систем и процессорных архитектур. 
Маленькие встраиваемые системы с ограниченным количеством ресурсов, такие как мобильные телефоны, могут быть запрограммированы с помощью Java Platform Micro Edition. Для рабочих станций существует Java Platform Standard Edition, предоставляющее модули для работы с UI, обработки XML и так далее. Разработка корпоративных приложений может быть упрощена с помощью Java Platform Enterprise Edition.
\par
Поскольку Java работает на большом количестве платформ, то приложения не распространяются как платформо-зависимый машинный код. Вместо этого используется концепция виртуальной машины. Исходный код Java программ компилируется в Java байткод, который вместе с таблицей символов и другой метаинформацией сохраняется в class файл.  Виртуальная машина Java определяется независимо от самого языка спецификацией (Tim Lindholm). Высокая производительность достигается путем just-in-time компиляции (Crimer). 

\subsection{Profile-guided optimization}
По сравнению со статически собранными бинарными файлами, исполнение кода с помощью виртуальной машины дает некоторые преимущества, такие как переносимость, безопасность, автоматическое управление памятью, динамическая загрузка кода. Однако это требует применение других алгоритмов оптимизации для получения высокой производительности.
\par
Оптимизация во время исполнения обычно базируется на профиле, собираемого в течении выполнения кода. 
Эта техника позволяет найти наиболее часто исполняемые участки программы, называемыми горячими точками “hot spots”. Горячий код может быть оптимизирован jit компилятором более агрессивно, чем статическим, поскольку виртуальная машина владеет большим контекстом об исполняемой программе. Оптимизации, основанные на сборе профиля, называются profile-guided.
\subsection{JVM}
Java HotSpot Virtual Machine была разработана Sun Microsystems. Виртуальная машина доступна для большого количества платформ и операционных систем. На данный момент поддерживаются архитектуры x64, arm и другие. JVM может быть работает в операционных системах на базе ядра linux и bsd, а так же windows. Виртуальная машина является частью JDK и обычно поставляется вместе с ней. На сегодняшний момент код OpenJDK открыт и доступен для скачивания. \textcolor{red}{Более того, лицензия позволяет свободно модифицировать код и распространять скомпилированные бинарные файлы в коммерческих целях.} Потому на момент написания работы существуют коммерческие JDK от других разработчиков.
\par
На сегодняшний момент существует множество компаний, которые предлагают свои реализации JDK, в большей или меньшей степени отличающихся от оригинальной. Сюда относятся Microsoft OpenJDK, Liberica JDK, Amazon Corretto, Azul Platform Prime и другие.
\par
Azul Platform Prime (или другими словами Zing) в первую очередь предназначена для использования в больших корпоративных приложениях, такие как высоконагруженные сервера, в которых важны короткие паузы сборки мусора и высокая производительность. 
Более того, в ее состав входит множество специфичных инструментов для анализа работы приложений, которые будут полезны Java разработчику, и виртуальная машина Zing, о которой пойдет речь дальше. В отличии от HotSpot, Zing имеет альтернативу стандартному С2 компилятору под названием Falcon, базирующимся на LLVM. собственный сборщик С4. Это конкурентный, поколенный сборщик мусора\cite{C4-perf}, предназначенный для крупных систем, чувствительным к паузам виртуальной машины.

\subsection{LLVM}
LLVM -- это акроним к "Low Level Virtual Machine". Это набор инструментов и библиотек для 
создания различных компиляторов. С его помощью были разработаны компиляторы для языков С, С++ и многих других. Кроме того, LLVM подходит для написания JIT-компиляторов языков с управляемой средой исполнения, поскольку имеет расширения для поддержки деоптимизаций и сборщика мусора. 
Важнейшим плюсом этой инфраструктуры является хорошо специфицированный промежуточный язык LLVM IR\cite{llvm-ref-man} (Intermediate representation), который фактически представляет собой высокоуровневый ассемблер. 
На основе этого представления работают различные анализаторы кода и оптимизаторы.
LLVM IR базируется на форме единичного статического присваивания (с англ. static single assugment). SSA -- это граф потока управления, в котором каждая переменная имеет только одно присваивание\cite{ssa-book}.
\par
Как упоминалось ранее, компилятор Falcon базируется на инструментарии LLVM. Это позволяет 
виртуальной машине Zing делать более сложный анализ Java кода и производить более сильные оптимизации, чем стандартный C2 компилятор\cite{falcon-gil}.
\par
Важно отметить одну особенность, как C2 и Falcon работают с интринсиками. 
Интринсики -- это специальные функции, реализующиеся самим компилятором. В JVM к их числу относятся широкий перечень математических функции, алгоритмы шифрования, в частности AES, Unsafe операции и так далее.
JVM применяют специально подготовленные разработчиками виртуальной машины функции, называемыми стабами (на англ. StubRoutines). Они обычно пишутся на ассемблере под конкретную
архитектуру и набор инструкций. Другой подход это генерация кода интринсика не лету для последующей открытой подстановки в тело вызывающей функции, что используется С2 компилятором для реализации Unsafe функций.
Поскольку Falcon базируется на LLVM, он использует интринсики, написанные LLVM IR. Это дает ряд преимущест. Во первых, независимость от архитектуры процессора, во вторых, упрощает разработку интринсиков.
Важно отметить, что работа с LLVM IR в Zing невозможна без понимания принципов взаимодейсвия сборщика мусора и компилятора.

\subsubsection{Взаимодействие GC и компилятора}
Для упрощения взаимодействия между сборщиком и скомпилированном кодом, многие GC организованы в терминах 3 абстракций: load и store barrier, safepoint\cite{gc-llvm}:
\begin{itemize}
	\item Load barrier, или барьер чтения – это кусок кода, исполняемый после операции загрузки указателя из памяти, но перед использованием прочитанного значения. Следует отметить, что некоторые сборщики могут не иметь барьера чтения.
	\item Store barrier, или барьер записи  – по аналогии с load barrier это фрагмент кода, который работает перед выполнением машинной инструкции загрузки адреса, но после получения сохраняемого значения.
	\item Safepoint, или безопасная точка – это позиция в коде, где поток исполнения может безопасно остановиться для дальнейшего анализа его контекста. После этой точки видимые компилируемому коду указатели могут быть изменены во время сборки мусора\cite{gc-handbook}. 
	Обычно безопасные точки расставляются в прологах функций и в циклах.
\end{itemize}
Сборщик С4 имеет оба вида барьеров. Их наличие приводит к ухудшению общей производительности, поскольку приходится исполнять дополнительный код при чтении или записи указателя. 
Потому разработчики стараются спроектировать как можно более простые барьеры, либо вовсе исключать их. 
Данная работа помогает частично решить проблему удаления load-барьеров.

\subsubsection{Представление Java объекта в памяти}
JVM использует единую модель памяти для все видов объектов, включая массивы и внутренние структуры данных. 
Ссылки на объекты представляют собой прямые указатели. Это обеспечивает быстрый доступ к полям объекта, однако требуется уметь распознавать тип ссылки во время исполнения. 
Каждый объект в Java имеет специальный заголовок, называемый markWord. Он необходим для отображения состояния объекта внутри JVM и имеет сравнительно небольшой размер. 
markWord это внутренняя структура данных, невидимая для Java программиста. Его устройство может быть различным в зависимости от версии JVM и от ее марки. 
В частности, в Zing размер markWord составляет 8 байт, что в 2 раза меньше, чем в Oracle Hotspot. 

\subsection{Система типов Java}
Все типы в языке Java можно разделить на две больших категории: примитивные и ссылочные типы \cite{java-spec}. На сегодняшний момент существует 8 примитивных типов: boolean, int,
long, float, double, byte, char, short. К ссылочным типам относятся \textcolor{red}{объекты классов, интерфейсов, массивов и специальный тип null}. Можем выделить некоторые отличия:
\par
Примитивные типы
\begin{enumerate}
	\item Передача по значению.
	\item Операция "==" сравнивает значения 
\end{enumerate}
Ссылочные типы
\begin{enumerate}
	\item Передача по ссылке.
	\item Имеют единый родительский класс java.lang.Object
	\item Операция "==" сравнивает указатели на объекты, а не их значения
\end{enumerate}
У ссылочных типов можно выделить подмножество, называемое boxing объекты. Это обертка для примитивных типов, которая позволяет представить их как ссылочные. В необходимо в ряде случаев, например, когда требуется передать примитивный тип в параметр шаблона. В некоторых случаях Java может неявно преобразовывать примитивные типы в ссылочные.
Следует отметить, что как и Java, JVM оперирует c примитивными и ссылочными типами\cite{jvm-spec}. Более того, для работы с примитивами существуют отдельные инструкции iadd, ladd, fadd, dadd и так далее.
\par
В связи с вышеперечисленным, на данный момент в Java нет возможности создавать собственные типы-значения.

\subsection{Постановка задачи}
На рисунке \ref{ref-graph}  изображен граф объектов, который может быть частью объектно-ориентированного приложения.
\begin{figure}[h]
	\caption{Массив объектов класса Point}\label{ref-graph}
	\includegraphics[width=0.95\linewidth]{image/reference.png}
\end{figure}
Класс Point содержит в себе два поля x, y типа int. Как описывалось ранее, Java работает с 
такого рода объектами как со ссылками. Потому массив "pts" содержит в себе указатели. В таком случае при доступе к полю "x" элемента i требуется дополнительное разыменования указателя, и только потом поступаемся по поля x.

\begin{lstlisting}
Point value = pts[i].x;
\end{lstlisting}
Однако в реальности мы имеем дополнительные издержки, связанные с исполнением load барьера и проверкой прочитанного значения на null:
\begin{lstlisting}
Point* tmp = &pts[i];
Point actual_value = load-barrier(tmp);
if (actual_value == null) {
	throw new NullPointerException();
}
\end{lstlisting}
В итоге это приводит к довольно дорогостоящему доступу к элементу массива. Было бы полезно избавиться от дополнительных накладных расходов на доступ к полю. Одним из возможных способов является расположение всего под графа в виде линейного участка памяти, как указано на рисунке \ref{values-graph}.

\begin{figure}[h]
	\caption{Массив значений}\label{values-graph}
	\includegraphics[width=0.65\linewidth]{image/flattened-points.png}
\end{figure}
По сравнению с предыдущей раскладкой объектов, у последней есть ряд преимуществ:
\begin{itemize}
	\item Улучшается локальность процессорного кеша. Поскольку объекты находятся рядом, а не разбросаны по всей куче, при чтении одного элемента в линейку кеша могут быть записаны соседние элементы. Это потенциально увеличивает производительность последовательного доступа к элементам массива.
	\item Удаляются load барьер и проверка на null. Адрес конкретного поля i-того элемента могут быть вычислен с помощью простой арифметики. Во многих случаях это обходится дешевле чтения ссылки из памяти. И поскольку виртуальная машина подразумевает, что в таком массиве не бывает указателей, равных null, проверки на null исчезают.
	\item Последовательный доступ к элементам может быть автоматически векторизован компилятором
\end{itemize}
К сожалению на данный момент JVM и язык Java не поддерживают возможность создания такого рода структуры данных. Данная работа посвящена ее разработке. Для этого были поставлены следующие задачи: 
\begin{enumerate}
	\item Изучить похожие работы
	\item Реализация данной структуры данных. Она подразумевает разработку удобного интерфейса, поддержку на уровне среды исполнения
	\item Измерить производительность и проанализировать результаты
	\item Найти и по возможности применить данную структуру данных для реализации других. Так же провести тестирование производительности
	\item Подготовить документацию  
\end{enumerate}
Данная работа проводилась на базе виртуальной машины Zing, разрабатываемой Azul Systems. Ее более подробное описание можно найти в секции \ref{Java}

\clearpage